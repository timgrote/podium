{
  "name": "Podium - Projects API (SQLite)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "podium-api",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-get",
      "name": "Webhook GET",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [260, 300],
      "webhookId": "podium-api"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "podium-api",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-post",
      "name": "Webhook POST",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [260, 500],
      "webhookId": "podium-api"
    },
    {
      "parameters": {
        "jsCode": "// Unified API handler - parses input and executes the right query\nconst input = $input.first().json;\nconst query = input.query || {};\nconst body = typeof input.body === 'string' ? JSON.parse(input.body) : (input.body || {});\n\n// Determine action\nconst action = query.action || body.action || 'list';\nconst job_id = query.job_id || body.job_id;\n\n// Build the SQL query based on action\nlet sql = '';\nlet result_type = 'rows';\n\nswitch(action) {\n  case 'list':\n    // Include contracts and invoices JSON for each project (no separate get_detail needed)\n    sql = `SELECT \n      p.id as job_id,\n      p.name as project_name,\n      p.status,\n      p.data_path,\n      p.notes,\n      p.current_invoice_id,\n      p.created_at,\n      p.updated_at,\n      c.id as client_id,\n      c.name as client_name,\n      c.email as client_email,\n      c.company as client_company,\n      c.phone as client_phone,\n      COALESCE(inv_totals.total_invoiced, 0) as total_invoiced,\n      COALESCE(inv_totals.total_paid, 0) as total_paid,\n      COALESCE((SELECT json_group_array(json_object(\n        'id', ct.id, 'total_amount', ct.total_amount, 'signed_at', ct.signed_at,\n        'file_path', ct.file_path, 'created_at', ct.created_at\n      )) FROM contracts ct WHERE ct.project_id = p.id AND ct.deleted_at IS NULL), '[]') as contracts_json,\n      COALESCE((SELECT json_group_array(json_object(\n        'id', inv.id, 'invoice_number', inv.invoice_number, 'total_due', inv.total_due,\n        'sent_status', inv.sent_status, 'paid_status', inv.paid_status,\n        'data_path', inv.data_path, 'previous_invoice_id', inv.previous_invoice_id,\n        'sent_at', inv.sent_at, 'paid_at', inv.paid_at, 'created_at', inv.created_at\n      )) FROM invoices inv WHERE inv.project_id = p.id AND inv.deleted_at IS NULL ORDER BY inv.created_at DESC), '[]') as invoices_json\n    FROM projects p\n    LEFT JOIN clients c ON p.client_id = c.id\n    LEFT JOIN (\n      SELECT project_id,\n        SUM(total_due) as total_invoiced,\n        SUM(CASE WHEN paid_status = 'paid' THEN total_due ELSE 0 END) as total_paid\n      FROM invoices WHERE deleted_at IS NULL GROUP BY project_id\n    ) inv_totals ON p.id = inv_totals.project_id\n    WHERE p.deleted_at IS NULL\n    ORDER BY p.created_at DESC`;\n    break;\n    \n  case 'get':\n    sql = `SELECT \n      p.id as job_id,\n      p.name as project_name,\n      p.status,\n      p.data_path,\n      p.notes,\n      p.current_invoice_id,\n      p.created_at,\n      p.updated_at,\n      c.id as client_id,\n      c.name as client_name,\n      c.email as client_email,\n      c.company as client_company\n    FROM projects p\n    LEFT JOIN clients c ON p.client_id = c.id\n    WHERE p.id = '${job_id}'\n      AND p.deleted_at IS NULL`;\n    result_type = 'single';\n    break;\n\n  case 'get_detail':\n    // Single query with embedded JSON for related entities\n    sql = `SELECT\n      p.id as job_id,\n      p.name as project_name,\n      p.status,\n      p.data_path,\n      p.notes,\n      p.current_invoice_id,\n      p.created_at,\n      p.updated_at,\n      c.id as client_id,\n      c.name as client_name,\n      c.email as client_email,\n      c.company as client_company,\n      c.phone as client_phone,\n      c.address as client_address,\n      COALESCE((SELECT json_group_array(json_object(\n        'id', pr.id, 'status', pr.status, 'total_fee', pr.total_fee,\n        'sent_at', pr.sent_at, 'created_at', pr.created_at\n      )) FROM proposals pr WHERE pr.project_id = p.id AND pr.deleted_at IS NULL), '[]') as proposals_json,\n      COALESCE((SELECT json_group_array(json_object(\n        'id', ct.id, 'total_amount', ct.total_amount, 'signed_at', ct.signed_at,\n        'file_path', ct.file_path, 'created_at', ct.created_at\n      )) FROM contracts ct WHERE ct.project_id = p.id AND ct.deleted_at IS NULL), '[]') as contracts_json,\n      COALESCE((SELECT json_group_array(json_object(\n        'id', inv.id, 'invoice_number', inv.invoice_number, 'total_due', inv.total_due,\n        'sent_status', inv.sent_status, 'paid_status', inv.paid_status,\n        'data_path', inv.data_path, 'previous_invoice_id', inv.previous_invoice_id,\n        'sent_at', inv.sent_at, 'paid_at', inv.paid_at, 'created_at', inv.created_at\n      )) FROM invoices inv WHERE inv.project_id = p.id AND inv.deleted_at IS NULL ORDER BY inv.created_at DESC), '[]') as invoices_json\n    FROM projects p\n    LEFT JOIN clients c ON p.client_id = c.id\n    WHERE p.id = '${job_id}'\n      AND p.deleted_at IS NULL`;\n    result_type = 'detail';\n    break;\n    \n  default:\n    sql = `SELECT 'unknown action: ${action}' as error`;\n    result_type = 'error';\n}\n\nreturn [{ json: { sql, action, result_type, job_id, body } }];"
      },
      "id": "parse-input",
      "name": "Parse & Build Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 400]
    },
    {
      "parameters": {
        "db_path": "/files/podium.db",
        "query_type": "SELECT",
        "query": "={{ $json.sql }}",
        "spread": true
      },
      "id": "sql-query",
      "name": "Execute SQL",
      "type": "n8n-nodes-sqlite3.sqliteNode",
      "typeVersion": 1,
      "position": [700, 400]
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst context = $('Parse & Build Query').first().json;\nconst action = context.action;\nconst result_type = context.result_type;\n\nif (result_type === 'error') {\n  return [{ json: { error: items[0]?.json?.error || 'Unknown error' } }];\n}\n\nconst rows = items.map(item => item.json);\n\nif (action === 'list') {\n  // Parse JSON fields for each project\n  const projects = rows.map(row => {\n    const project = { ...row };\n    project.contracts = JSON.parse(row.contracts_json || '[]');\n    project.invoices = JSON.parse(row.invoices_json || '[]');\n    delete project.contracts_json;\n    delete project.invoices_json;\n    return project;\n  });\n  return [{ json: { projects } }];\n}\n\nif (action === 'get') {\n  if (rows.length === 0) {\n    return [{ json: { error: 'Project not found' } }];\n  }\n  return [{ json: { project: rows[0] } }];\n}\n\nif (action === 'get_detail') {\n  if (rows.length === 0) {\n    return [{ json: { error: 'Project not found' } }];\n  }\n  const row = rows[0];\n  // Parse JSON strings into arrays\n  const project = {\n    ...row,\n    proposals: JSON.parse(row.proposals_json || '[]'),\n    contracts: JSON.parse(row.contracts_json || '[]'),\n    invoices: JSON.parse(row.invoices_json || '[]')\n  };\n  // Remove the raw JSON fields\n  delete project.proposals_json;\n  delete project.contracts_json;\n  delete project.invoices_json;\n  return [{ json: { project } }];\n}\n\nreturn [{ json: { success: true, data: rows } }];"
      },
      "id": "format-response",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [920, 400]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1140, 400]
    }
  ],
  "connections": {
    "Webhook GET": { "main": [[{ "node": "Parse & Build Query", "type": "main", "index": 0 }]] },
    "Webhook POST": { "main": [[{ "node": "Parse & Build Query", "type": "main", "index": 0 }]] },
    "Parse & Build Query": { "main": [[{ "node": "Execute SQL", "type": "main", "index": 0 }]] },
    "Execute SQL": { "main": [[{ "node": "Format Response", "type": "main", "index": 0 }]] },
    "Format Response": { "main": [[{ "node": "Respond", "type": "main", "index": 0 }]] }
  },
  "settings": { "executionOrder": "v1" },
  "staticData": null
}
